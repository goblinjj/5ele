# 战斗系统实现计划

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** 完善单人战斗逻辑，将战斗引擎提取到 shared 包，为多人模式打基础。

**Architecture:** 战斗逻辑抽取到 `packages/shared/src/logic/` 目录，客户端的 BattleScene 调用引擎执行战斗并播放动画。掉落物改为自动拾取，战斗后直接显示三选一节点。

**Tech Stack:** TypeScript, Phaser 3, pnpm workspaces

---

## Task 1: 扩展 Equipment 类型 - 添加 speed 属性

**Files:**
- Modify: `packages/shared/src/types/Equipment.ts:64-83`

**Step 1: 修改 Equipment 接口添加 speed 字段**

在 `Equipment` 接口中添加 `speed` 可选属性：

```typescript
export interface Equipment {
  id: string;
  name: string;
  type: EquipmentType;
  rarity: Rarity;

  // 五行属性
  wuxing: Wuxing;
  wuxingLevel: number;

  // 基础属性（低数值系统）
  attack?: number;   // 攻击力 1-10
  defense?: number;  // 防御力 1-10
  speed?: number;    // 速度 0-3 (新增)

  // 附带技能
  skill?: Skill;

  // 升级等级
  upgradeLevel: number;
}
```

**Step 2: 添加 getTotalSpeed 函数**

在文件末尾添加：

```typescript
/**
 * 计算玩家总速度
 */
export function getTotalSpeed(equipment: PlayerEquipment): number {
  let speed = equipment.weapon?.speed ?? 0;
  speed += equipment.armor?.speed ?? 0;

  for (const treasure of equipment.treasures) {
    speed += treasure.speed ?? 0;
  }

  return speed;
}
```

**Step 3: 验证编译**

Run: `cd /Volumes/T7/work/fighting && pnpm build:shared`
Expected: 编译成功，无错误

**Step 4: Commit**

```bash
git add packages/shared/src/types/Equipment.ts
git commit -m "feat(shared): add speed attribute to Equipment interface"
```

---

## Task 2: 扩展 Wuxing 类型 - 添加速度修正常量

**Files:**
- Modify: `packages/shared/src/types/Wuxing.ts`

**Step 1: 添加五行速度修正常量**

在 `WUXING_COLORS` 后添加：

```typescript
/**
 * 五行速度修正
 * 火最快 (+2)，土最慢 (-2)
 */
export const WUXING_SPEED_MODIFIER: Record<Wuxing, number> = {
  [Wuxing.FIRE]: 2,
  [Wuxing.METAL]: 1,
  [Wuxing.WOOD]: 0,
  [Wuxing.WATER]: -1,
  [Wuxing.EARTH]: -2,
};

/**
 * 五行速度优先级（速度相同时的排序）
 */
export const WUXING_SPEED_PRIORITY: Record<Wuxing, number> = {
  [Wuxing.FIRE]: 5,
  [Wuxing.METAL]: 4,
  [Wuxing.WOOD]: 3,
  [Wuxing.WATER]: 2,
  [Wuxing.EARTH]: 1,
};
```

**Step 2: 验证编译**

Run: `cd /Volumes/T7/work/fighting && pnpm build:shared`
Expected: 编译成功

**Step 3: Commit**

```bash
git add packages/shared/src/types/Wuxing.ts
git commit -m "feat(shared): add wuxing speed modifiers"
```

---

## Task 3: 创建战斗引擎核心类型

**Files:**
- Create: `packages/shared/src/logic/BattleTypes.ts`

**Step 1: 创建 logic 目录和类型文件**

```typescript
import { Wuxing, WuxingLevel } from '../types/Wuxing.js';
import { Skill } from '../types/Equipment.js';

/**
 * 战斗配置
 */
export interface BattleConfig {
  allowEquipmentChange: boolean;  // PvE: true, PvP最终战: false
  isPvP: boolean;
}

/**
 * 战斗者
 */
export interface Combatant {
  id: string;
  name: string;
  hp: number;
  maxHp: number;
  attack: number;
  defense: number;
  speed: number;
  attackWuxing: WuxingLevel | null;
  defenseWuxing: WuxingLevel | null;
  skills: Skill[];
  isPlayer: boolean;

  // 临时状态
  frozen: boolean;
  attackDebuff: number;
}

/**
 * 战斗事件类型
 */
export type BattleEventType =
  | 'battle_start'
  | 'round_start'
  | 'turn_start'
  | 'attack'
  | 'skill_trigger'
  | 'damage'
  | 'heal'
  | 'miss'
  | 'death'
  | 'frozen_skip'
  | 'equip_change'
  | 'round_end'
  | 'battle_end';

/**
 * 战斗事件
 */
export interface BattleEvent {
  type: BattleEventType;
  actorId?: string;
  targetId?: string;
  value?: number;
  skillName?: string;
  wuxingEffect?: 'conquer' | 'generate' | 'neutral';
  isCritical?: boolean;
  message?: string;
}

/**
 * 战斗结果
 */
export interface BattleResult {
  winnerId: string | null;  // null = 全部死亡或怪物获胜
  events: BattleEvent[];
  survivingCombatants: Combatant[];
}

/**
 * 空手攻击属性
 */
export const UNARMED_STATS = {
  attack: 1,
  speed: 0,
};
```

**Step 2: 导出类型**

修改 `packages/shared/src/index.ts`，添加：

```typescript
export * from './logic/BattleTypes.js';
```

**Step 3: 验证编译**

Run: `cd /Volumes/T7/work/fighting && pnpm build:shared`
Expected: 编译成功

**Step 4: Commit**

```bash
git add packages/shared/src/logic/BattleTypes.ts packages/shared/src/index.ts
git commit -m "feat(shared): add battle engine types"
```

---

## Task 4: 实现伤害计算器

**Files:**
- Create: `packages/shared/src/logic/DamageCalculator.ts`

**Step 1: 创建伤害计算模块**

```typescript
import { Wuxing, WuxingLevel, getWuxingRelation } from '../types/Wuxing.js';
import { Combatant } from './BattleTypes.js';

/**
 * 伤害计算结果
 */
export interface DamageResult {
  damage: number;  // 负数表示治疗敌人
  wuxingEffect: 'conquer' | 'generate' | 'neutral';
  isCritical: boolean;
}

/**
 * 计算基础伤害
 */
export function calculateBaseDamage(attack: number, defense: number): number {
  return Math.max(attack - defense, 1);
}

/**
 * 计算五行伤害修正
 */
export function calculateWuxingMultiplier(
  attackWuxing: WuxingLevel | null,
  defenseWuxing: WuxingLevel | null
): { multiplier: number; effect: 'conquer' | 'generate' | 'neutral' } {
  // 无五行攻击 = 纯物理
  if (!attackWuxing || !defenseWuxing) {
    return { multiplier: 1.0, effect: 'neutral' };
  }

  const relation = getWuxingRelation(attackWuxing.wuxing, defenseWuxing.wuxing);
  const levelDiff = attackWuxing.level - defenseWuxing.level;

  switch (relation) {
    case 'conquer':
      // 相克：基础 1.5 倍，每级差 ±10%
      return {
        multiplier: 1.5 + levelDiff * 0.1,
        effect: 'conquer',
      };
    case 'generate':
      // 相生：治疗敌人，基础 -0.5 倍
      return {
        multiplier: -(0.5 + levelDiff * 0.05),
        effect: 'generate',
      };
    default:
      // 中性：每级差 ±5%
      return {
        multiplier: 1.0 + levelDiff * 0.05,
        effect: 'neutral',
      };
  }
}

/**
 * 计算最终伤害
 */
export function calculateFinalDamage(
  attacker: Combatant,
  defender: Combatant,
  ignoreDefense: number = 0
): DamageResult {
  // 计算有效攻击力（考虑 debuff）
  const effectiveAttack = Math.max(1, attacker.attack - attacker.attackDebuff);
  const effectiveDefense = Math.max(0, defender.defense - ignoreDefense);

  // 基础伤害
  const baseDamage = calculateBaseDamage(effectiveAttack, effectiveDefense);

  // 五行修正
  const { multiplier, effect } = calculateWuxingMultiplier(
    attacker.attackWuxing,
    defender.defenseWuxing
  );

  // 最终伤害
  let finalDamage: number;
  if (multiplier < 0) {
    // 相生：治疗敌人
    finalDamage = -Math.floor(baseDamage * Math.abs(multiplier));
  } else {
    finalDamage = Math.floor(baseDamage * multiplier);
  }

  return {
    damage: finalDamage,
    wuxingEffect: effect,
    isCritical: false,
  };
}
```

**Step 2: 导出模块**

修改 `packages/shared/src/index.ts`，添加：

```typescript
export * from './logic/DamageCalculator.js';
```

**Step 3: 验证编译**

Run: `cd /Volumes/T7/work/fighting && pnpm build:shared`
Expected: 编译成功

**Step 4: Commit**

```bash
git add packages/shared/src/logic/DamageCalculator.ts packages/shared/src/index.ts
git commit -m "feat(shared): implement damage calculator with wuxing modifiers"
```

---

## Task 5: 实现速度排序器

**Files:**
- Create: `packages/shared/src/logic/SpeedResolver.ts`

**Step 1: 创建速度排序模块**

```typescript
import { WUXING_SPEED_MODIFIER, WUXING_SPEED_PRIORITY } from '../types/Wuxing.js';
import { Combatant } from './BattleTypes.js';

/**
 * 计算战斗者的最终速度
 */
export function calculateCombatantSpeed(combatant: Combatant): number {
  const baseSpeed = combatant.speed;
  const wuxingMod = combatant.attackWuxing
    ? WUXING_SPEED_MODIFIER[combatant.attackWuxing.wuxing]
    : 0;
  return baseSpeed + wuxingMod;
}

/**
 * 按速度排序战斗者（速度高的在前）
 */
export function sortBySpeed(combatants: Combatant[]): Combatant[] {
  return [...combatants].sort((a, b) => {
    const speedA = calculateCombatantSpeed(a);
    const speedB = calculateCombatantSpeed(b);

    // 速度不同：速度高的先行动
    if (speedA !== speedB) {
      return speedB - speedA;
    }

    // 速度相同：按五行优先级
    const priorityA = a.attackWuxing
      ? WUXING_SPEED_PRIORITY[a.attackWuxing.wuxing]
      : 0;
    const priorityB = b.attackWuxing
      ? WUXING_SPEED_PRIORITY[b.attackWuxing.wuxing]
      : 0;

    return priorityB - priorityA;
  });
}

/**
 * 获取存活的战斗者
 */
export function getAliveCombatants(combatants: Combatant[]): Combatant[] {
  return combatants.filter(c => c.hp > 0);
}
```

**Step 2: 导出模块**

修改 `packages/shared/src/index.ts`，添加：

```typescript
export * from './logic/SpeedResolver.js';
```

**Step 3: 验证编译**

Run: `cd /Volumes/T7/work/fighting && pnpm build:shared`
Expected: 编译成功

**Step 4: Commit**

```bash
git add packages/shared/src/logic/SpeedResolver.ts packages/shared/src/index.ts
git commit -m "feat(shared): implement speed resolver with wuxing priority"
```

---

## Task 6: 实现技能处理器

**Files:**
- Create: `packages/shared/src/logic/SkillProcessor.ts`

**Step 1: 创建技能处理模块**

```typescript
import { Skill, SkillTrigger } from '../types/Equipment.js';
import { Combatant, BattleEvent } from './BattleTypes.js';

/**
 * 技能处理结果
 */
export interface SkillResult {
  triggered: boolean;
  events: BattleEvent[];
  damageMultiplier?: number;
  bonusDamage?: number;
  healAmount?: number;
  dodged?: boolean;
  frozen?: boolean;
  attackDebuff?: number;
}

/**
 * 处理被动技能（在战斗初始化时应用）
 */
export function applyPassiveSkills(combatant: Combatant): void {
  for (const skill of combatant.skills) {
    if (skill.trigger !== SkillTrigger.PASSIVE) continue;

    if (skill.attackBonus) {
      combatant.attack += skill.attackBonus;
    }
    if (skill.defenseBonus) {
      combatant.defense += skill.defenseBonus;
    }
    // 五行等级加成在初始化时已经处理
  }
}

/**
 * 处理战斗开始技能
 */
export function processBattleStartSkills(
  combatant: Combatant,
  allCombatants: Combatant[]
): BattleEvent[] {
  const events: BattleEvent[] = [];

  for (const skill of combatant.skills) {
    if (skill.trigger !== SkillTrigger.BATTLE_START) continue;

    events.push({
      type: 'skill_trigger',
      actorId: combatant.id,
      skillName: skill.name,
    });

    // 回复效果
    if (skill.heal && skill.heal > 0) {
      const healAmount = Math.min(skill.heal, combatant.maxHp - combatant.hp);
      combatant.hp += healAmount;
      events.push({
        type: 'heal',
        actorId: combatant.id,
        targetId: combatant.id,
        value: healAmount,
      });
    }

    // 对敌方造成伤害
    if (skill.damage && skill.damage > 0) {
      const enemies = allCombatants.filter(c => c.isPlayer !== combatant.isPlayer && c.hp > 0);
      for (const enemy of enemies) {
        enemy.hp = Math.max(0, enemy.hp - skill.damage);
        events.push({
          type: 'damage',
          actorId: combatant.id,
          targetId: enemy.id,
          value: skill.damage,
        });
        if (enemy.hp <= 0) {
          events.push({ type: 'death', targetId: enemy.id });
        }
      }
    }
  }

  return events;
}

/**
 * 处理攻击时技能（ON_HIT）
 */
export function processOnHitSkills(
  attacker: Combatant,
  defender: Combatant,
  baseDamage: number
): SkillResult {
  const result: SkillResult = {
    triggered: false,
    events: [],
    damageMultiplier: 1,
    bonusDamage: 0,
  };

  for (const skill of attacker.skills) {
    if (skill.trigger !== SkillTrigger.ON_HIT) continue;

    const chance = skill.triggerChance ?? 1;
    if (Math.random() >= chance) continue;

    result.triggered = true;
    result.events.push({
      type: 'skill_trigger',
      actorId: attacker.id,
      skillName: skill.name,
    });

    // 双倍伤害
    if (skill.damageMultiplier && skill.damageMultiplier > 1) {
      result.damageMultiplier = skill.damageMultiplier;
    }

    // 额外伤害
    if (skill.damage) {
      result.bonusDamage = (result.bonusDamage ?? 0) + skill.damage;
    }

    // 吸血
    if (skill.heal) {
      result.healAmount = (result.healAmount ?? 0) + skill.heal;
    }
  }

  return result;
}

/**
 * 处理防御时技能（ON_DEFEND）
 */
export function processOnDefendSkills(
  defender: Combatant,
  attacker: Combatant
): SkillResult {
  const result: SkillResult = {
    triggered: false,
    events: [],
  };

  for (const skill of defender.skills) {
    if (skill.trigger !== SkillTrigger.ON_DEFEND) continue;

    const chance = skill.triggerChance ?? 1;
    if (Math.random() >= chance) continue;

    result.triggered = true;
    result.events.push({
      type: 'skill_trigger',
      actorId: defender.id,
      skillName: skill.name,
    });

    // 闪避
    if (skill.dodge) {
      result.dodged = true;
      result.events.push({
        type: 'miss',
        actorId: attacker.id,
        targetId: defender.id,
      });
      return result; // 闪避后不再处理其他技能
    }

    // 缴械（降低攻击力）
    if (skill.attackBonus && skill.attackBonus < 0) {
      result.attackDebuff = Math.abs(skill.attackBonus);
    }

    // 冻结（通过 skill id 判断）
    if (skill.id === 'skill_xuanbing') {
      result.frozen = true;
    }
  }

  return result;
}

/**
 * 获取无视防御值
 */
export function getIgnoreDefense(combatant: Combatant): number {
  let ignoreDefense = 0;
  for (const skill of combatant.skills) {
    if (skill.trigger === SkillTrigger.PASSIVE && skill.ignoreDefense) {
      ignoreDefense += skill.ignoreDefense;
    }
  }
  return ignoreDefense;
}

/**
 * 获取被动自损值
 */
export function getPassiveSelfDamage(combatant: Combatant): { damage: number; skillName: string } | null {
  for (const skill of combatant.skills) {
    if (skill.trigger === SkillTrigger.PASSIVE && skill.selfDamage) {
      return { damage: skill.selfDamage, skillName: skill.name };
    }
  }
  return null;
}
```

**Step 2: 导出模块**

修改 `packages/shared/src/index.ts`，添加：

```typescript
export * from './logic/SkillProcessor.js';
```

**Step 3: 验证编译**

Run: `cd /Volumes/T7/work/fighting && pnpm build:shared`
Expected: 编译成功

**Step 4: Commit**

```bash
git add packages/shared/src/logic/SkillProcessor.ts packages/shared/src/index.ts
git commit -m "feat(shared): implement skill processor for all trigger types"
```

---

## Task 7: 实现战斗引擎主类

**Files:**
- Create: `packages/shared/src/logic/BattleEngine.ts`

**Step 1: 创建战斗引擎**

```typescript
import { Combatant, BattleConfig, BattleEvent, BattleResult } from './BattleTypes.js';
import { calculateFinalDamage } from './DamageCalculator.js';
import { sortBySpeed, getAliveCombatants } from './SpeedResolver.js';
import {
  applyPassiveSkills,
  processBattleStartSkills,
  processOnHitSkills,
  processOnDefendSkills,
  getIgnoreDefense,
  getPassiveSelfDamage,
} from './SkillProcessor.js';

const MAX_ROUNDS = 50;

/**
 * 战斗引擎
 */
export class BattleEngine {
  private combatants: Combatant[];
  private events: BattleEvent[] = [];
  private config: BattleConfig;
  private roundNumber: number = 0;

  constructor(combatants: Combatant[], config: BattleConfig) {
    this.combatants = combatants.map(c => ({ ...c })); // 深拷贝
    this.config = config;
  }

  /**
   * 执行完整战斗
   */
  run(): BattleResult {
    this.initBattle();
    this.battleStartPhase();
    this.combatPhase();
    return this.buildResult();
  }

  /**
   * 初始化战斗
   */
  private initBattle(): void {
    // 应用被动技能
    for (const combatant of this.combatants) {
      applyPassiveSkills(combatant);
    }

    this.events.push({ type: 'battle_start' });
  }

  /**
   * 战斗开始阶段
   */
  private battleStartPhase(): void {
    for (const combatant of this.combatants) {
      const events = processBattleStartSkills(combatant, this.combatants);
      this.events.push(...events);
    }
  }

  /**
   * 战斗主循环
   */
  private combatPhase(): void {
    while (this.roundNumber < MAX_ROUNDS) {
      this.roundNumber++;
      this.events.push({ type: 'round_start', value: this.roundNumber });

      const alive = getAliveCombatants(this.combatants);

      // 检查胜负
      const alivePlayers = alive.filter(c => c.isPlayer);
      const aliveEnemies = alive.filter(c => !c.isPlayer);

      if (alivePlayers.length === 0 || aliveEnemies.length === 0) {
        break;
      }

      // 按速度排序行动
      const turnOrder = sortBySpeed(alive);

      for (const actor of turnOrder) {
        if (actor.hp <= 0) continue;

        // 处理冻结状态
        if (actor.frozen) {
          this.events.push({ type: 'frozen_skip', actorId: actor.id });
          actor.frozen = false;
          continue;
        }

        // 重置临时 debuff
        actor.attackDebuff = 0;

        // 处理被动自损
        const selfDamage = getPassiveSelfDamage(actor);
        if (selfDamage) {
          this.events.push({
            type: 'skill_trigger',
            actorId: actor.id,
            skillName: selfDamage.skillName,
          });
          actor.hp = Math.max(0, actor.hp - selfDamage.damage);
          this.events.push({
            type: 'damage',
            actorId: actor.id,
            targetId: actor.id,
            value: selfDamage.damage,
          });
          if (actor.hp <= 0) {
            this.events.push({ type: 'death', targetId: actor.id });
            continue;
          }
        }

        // 选择目标
        const target = this.selectTarget(actor);
        if (!target) continue;

        // 执行攻击
        this.executeAttack(actor, target);

        // 再次检查胜负
        const stillAlive = getAliveCombatants(this.combatants);
        const playersLeft = stillAlive.filter(c => c.isPlayer).length;
        const enemiesLeft = stillAlive.filter(c => !c.isPlayer).length;

        if (playersLeft === 0 || enemiesLeft === 0) {
          break;
        }
      }

      this.events.push({ type: 'round_end', value: this.roundNumber });
    }

    this.events.push({ type: 'battle_end' });
  }

  /**
   * 选择攻击目标
   */
  private selectTarget(actor: Combatant): Combatant | null {
    const enemies = this.combatants.filter(
      c => c.isPlayer !== actor.isPlayer && c.hp > 0
    );
    if (enemies.length === 0) return null;
    return enemies[Math.floor(Math.random() * enemies.length)];
  }

  /**
   * 执行攻击
   */
  private executeAttack(attacker: Combatant, defender: Combatant): void {
    this.events.push({
      type: 'turn_start',
      actorId: attacker.id,
      targetId: defender.id,
    });

    // 处理防御技能
    const defendResult = processOnDefendSkills(defender, attacker);
    this.events.push(...defendResult.events);

    if (defendResult.dodged) {
      return; // 被闪避
    }

    if (defendResult.attackDebuff) {
      attacker.attackDebuff += defendResult.attackDebuff;
    }

    if (defendResult.frozen) {
      attacker.frozen = true;
    }

    // 计算伤害
    const ignoreDefense = getIgnoreDefense(attacker);
    const damageResult = calculateFinalDamage(attacker, defender, ignoreDefense);

    // 处理攻击技能
    const hitResult = processOnHitSkills(attacker, defender, damageResult.damage);
    this.events.push(...hitResult.events);

    // 计算最终伤害
    let finalDamage = damageResult.damage;
    if (finalDamage > 0) {
      finalDamage = Math.floor(finalDamage * (hitResult.damageMultiplier ?? 1));
      finalDamage += hitResult.bonusDamage ?? 0;
    }

    // 应用伤害或治疗
    if (finalDamage >= 0) {
      defender.hp = Math.max(0, defender.hp - finalDamage);
      this.events.push({
        type: 'damage',
        actorId: attacker.id,
        targetId: defender.id,
        value: finalDamage,
        wuxingEffect: damageResult.wuxingEffect,
        isCritical: (hitResult.damageMultiplier ?? 1) > 1,
      });
    } else {
      // 相生：治疗敌人
      const healAmount = Math.min(-finalDamage, defender.maxHp - defender.hp);
      defender.hp += healAmount;
      this.events.push({
        type: 'heal',
        actorId: attacker.id,
        targetId: defender.id,
        value: healAmount,
        wuxingEffect: damageResult.wuxingEffect,
      });
    }

    // 处理吸血
    if (hitResult.healAmount && hitResult.healAmount > 0) {
      const healAmount = Math.min(hitResult.healAmount, attacker.maxHp - attacker.hp);
      attacker.hp += healAmount;
      this.events.push({
        type: 'heal',
        actorId: attacker.id,
        targetId: attacker.id,
        value: healAmount,
      });
    }

    // 检查死亡
    if (defender.hp <= 0) {
      this.events.push({ type: 'death', targetId: defender.id });
    }
  }

  /**
   * 构建战斗结果
   */
  private buildResult(): BattleResult {
    const alive = getAliveCombatants(this.combatants);
    const alivePlayers = alive.filter(c => c.isPlayer);

    let winnerId: string | null = null;
    if (alivePlayers.length > 0) {
      winnerId = alivePlayers[0].id;
    }

    return {
      winnerId,
      events: this.events,
      survivingCombatants: alive,
    };
  }
}
```

**Step 2: 导出模块**

修改 `packages/shared/src/index.ts`，添加：

```typescript
export * from './logic/BattleEngine.js';
```

**Step 3: 验证编译**

Run: `cd /Volumes/T7/work/fighting && pnpm build:shared`
Expected: 编译成功

**Step 4: Commit**

```bash
git add packages/shared/src/logic/BattleEngine.ts packages/shared/src/index.ts
git commit -m "feat(shared): implement BattleEngine with full combat loop"
```

---

## Task 8: 创建敌人数据库

**Files:**
- Create: `packages/shared/src/data/EnemyDatabase.ts`

**Step 1: 创建敌人模板数据**

```typescript
import { Wuxing } from '../types/Wuxing.js';
import { Skill, SkillTrigger } from '../types/Equipment.js';
import { Combatant } from '../logic/BattleTypes.js';

/**
 * 敌人模板
 */
export interface EnemyTemplate {
  id: string;
  name: string;
  hp: number;
  attack: number;
  defense: number;
  speed: number;
  wuxing: Wuxing;
  wuxingLevel: number;
  skills: Skill[];
}

/**
 * 普通怪物模板
 */
export const NORMAL_ENEMIES: EnemyTemplate[] = [
  {
    id: 'goblin',
    name: '小妖',
    hp: 6,
    attack: 2,
    defense: 1,
    speed: 1,
    wuxing: Wuxing.WOOD,
    wuxingLevel: 1,
    skills: [],
  },
  {
    id: 'wolf',
    name: '狼妖',
    hp: 8,
    attack: 3,
    defense: 1,
    speed: 2,
    wuxing: Wuxing.METAL,
    wuxingLevel: 1,
    skills: [],
  },
  {
    id: 'snake',
    name: '蛇妖',
    hp: 5,
    attack: 2,
    defense: 0,
    speed: 3,
    wuxing: Wuxing.WATER,
    wuxingLevel: 1,
    skills: [],
  },
  {
    id: 'fox',
    name: '狐妖',
    hp: 7,
    attack: 2,
    defense: 1,
    speed: 2,
    wuxing: Wuxing.FIRE,
    wuxingLevel: 1,
    skills: [],
  },
];

/**
 * 精英怪物模板
 */
export const ELITE_ENEMIES: EnemyTemplate[] = [
  {
    id: 'bear',
    name: '熊罴怪',
    hp: 18,
    attack: 4,
    defense: 3,
    speed: 0,
    wuxing: Wuxing.EARTH,
    wuxingLevel: 2,
    skills: [],
  },
  {
    id: 'spider',
    name: '蜘蛛精',
    hp: 14,
    attack: 5,
    defense: 1,
    speed: 2,
    wuxing: Wuxing.FIRE,
    wuxingLevel: 2,
    skills: [],
  },
  {
    id: 'tiger',
    name: '虎力大仙',
    hp: 16,
    attack: 4,
    defense: 2,
    speed: 2,
    wuxing: Wuxing.METAL,
    wuxingLevel: 2,
    skills: [],
  },
];

/**
 * Boss 模板
 */
export const BOSS_ENEMIES: EnemyTemplate[] = [
  {
    id: 'niuwang',
    name: '牛魔王',
    hp: 40,
    attack: 5,
    defense: 3,
    speed: 1,
    wuxing: Wuxing.FIRE,
    wuxingLevel: 3,
    skills: [
      {
        id: 'skill_niuqi',
        name: '牛气冲天',
        description: '战斗开始时攻击+2',
        trigger: SkillTrigger.PASSIVE,
        attackBonus: 2,
      },
    ],
  },
];

/**
 * 根据节点类型生成敌人
 */
export function generateEnemies(
  nodeType: 'normal' | 'elite' | 'final',
  round: number
): Combatant[] {
  const scaling = 1 + round * 0.15;
  const enemies: Combatant[] = [];

  if (nodeType === 'normal') {
    // 普通战斗：1-2 个小怪
    const count = Math.random() < 0.5 ? 1 : 2;
    for (let i = 0; i < count; i++) {
      const template = NORMAL_ENEMIES[Math.floor(Math.random() * NORMAL_ENEMIES.length)];
      enemies.push(createCombatantFromTemplate(template, i, scaling));
    }
  } else if (nodeType === 'elite') {
    // 精英战斗：1 个精英怪
    const template = ELITE_ENEMIES[Math.floor(Math.random() * ELITE_ENEMIES.length)];
    enemies.push(createCombatantFromTemplate(template, 0, scaling));
  } else {
    // Boss 战斗
    const template = BOSS_ENEMIES[0];
    enemies.push(createCombatantFromTemplate(template, 0, scaling));
  }

  return enemies;
}

function createCombatantFromTemplate(
  template: EnemyTemplate,
  index: number,
  scaling: number
): Combatant {
  const scaledHp = Math.floor(template.hp * scaling);
  return {
    id: `enemy_${template.id}_${index}_${Date.now()}`,
    name: template.name,
    hp: scaledHp,
    maxHp: scaledHp,
    attack: Math.floor(template.attack * scaling),
    defense: Math.floor(template.defense * scaling),
    speed: template.speed,
    attackWuxing: { wuxing: template.wuxing, level: template.wuxingLevel },
    defenseWuxing: { wuxing: template.wuxing, level: template.wuxingLevel },
    skills: [...template.skills],
    isPlayer: false,
    frozen: false,
    attackDebuff: 0,
  };
}
```

**Step 2: 导出模块**

修改 `packages/shared/src/index.ts`，添加：

```typescript
export * from './data/EnemyDatabase.js';
```

**Step 3: 验证编译**

Run: `cd /Volumes/T7/work/fighting && pnpm build:shared`
Expected: 编译成功

**Step 4: Commit**

```bash
git add packages/shared/src/data/EnemyDatabase.ts packages/shared/src/index.ts
git commit -m "feat(shared): add enemy database with templates and scaling"
```

---

## Task 9: 创建掉落生成器

**Files:**
- Create: `packages/shared/src/logic/LootGenerator.ts`

**Step 1: 创建掉落生成模块**

```typescript
import { Equipment, EquipmentType, Rarity } from '../types/Equipment.js';
import { Wuxing, WUXING_NAMES } from '../types/Wuxing.js';
import { BOSS_DROPS, getLegendaryEquipment } from '../data/EquipmentDatabase.js';

/**
 * 掉落结果
 */
export interface LootResult {
  items: Equipment[];
}

/**
 * 生成战斗掉落
 */
export function generateLoot(
  nodeType: 'normal' | 'elite' | 'final',
  round: number
): LootResult {
  const items: Equipment[] = [];

  // 尝试 Boss 掉落
  const bossDrop = tryBossDrop(nodeType);
  if (bossDrop) {
    items.push(bossDrop);
  }

  // 确定掉落数量
  let lootCount: number;
  switch (nodeType) {
    case 'normal':
      lootCount = randomInt(1, 3);
      break;
    case 'elite':
      lootCount = randomInt(2, 4);
      break;
    case 'final':
      lootCount = randomInt(3, 5);
      break;
  }

  // 生成随机装备
  const isHighQuality = nodeType === 'elite' || nodeType === 'final';
  for (let i = items.length; i < lootCount; i++) {
    items.push(generateRandomEquipment(isHighQuality, round));
  }

  return { items };
}

function tryBossDrop(nodeType: 'normal' | 'elite' | 'final'): Equipment | null {
  let bossId: string | null = null;

  if (nodeType === 'final') {
    bossId = 'boss_final';
  } else if (nodeType === 'elite') {
    const eliteBosses = ['boss_bajie', 'boss_wujing', 'boss_dragon'];
    bossId = eliteBosses[Math.floor(Math.random() * eliteBosses.length)];
  }

  if (!bossId) return null;

  const bossDropTable = BOSS_DROPS.find(b => b.bossId === bossId);
  if (!bossDropTable) return null;

  for (const drop of bossDropTable.drops) {
    if (Math.random() < drop.dropRate) {
      const legendary = getLegendaryEquipment(drop.equipmentId);
      if (legendary) {
        return {
          ...legendary,
          id: `${legendary.id}_${Date.now()}`,
        };
      }
    }
  }

  return null;
}

function generateRandomEquipment(isHighQuality: boolean, round: number): Equipment {
  const types = [EquipmentType.WEAPON, EquipmentType.ARMOR, EquipmentType.TREASURE];
  const type = types[Math.floor(Math.random() * types.length)];

  const wuxings = Object.values(Wuxing);
  const wuxing = wuxings[Math.floor(Math.random() * wuxings.length)] as Wuxing;

  const rarityRoll = Math.random();
  let rarity: Rarity;
  if (isHighQuality) {
    rarity = rarityRoll < 0.3 ? Rarity.EPIC : rarityRoll < 0.7 ? Rarity.RARE : Rarity.UNCOMMON;
  } else {
    rarity = rarityRoll < 0.1 ? Rarity.RARE : rarityRoll < 0.4 ? Rarity.UNCOMMON : Rarity.COMMON;
  }

  const baseStats = getBaseStats(rarity);
  const baseSpeed = Math.floor(Math.random() * 2); // 0-1

  return {
    id: `equip_${Date.now()}_${Math.random().toString(36).slice(2)}`,
    name: generateName(type, wuxing, rarity),
    type,
    rarity,
    wuxing,
    wuxingLevel: rarity === Rarity.EPIC ? 2 : 1,
    attack: type === EquipmentType.WEAPON || type === EquipmentType.TREASURE ? baseStats : undefined,
    defense: type === EquipmentType.ARMOR || type === EquipmentType.TREASURE ? baseStats : undefined,
    speed: baseSpeed,
    upgradeLevel: 0,
  };
}

function getBaseStats(rarity: Rarity): number {
  switch (rarity) {
    case Rarity.COMMON: return 1;
    case Rarity.UNCOMMON: return 2;
    case Rarity.RARE: return 3;
    case Rarity.EPIC: return 4;
    case Rarity.LEGENDARY: return 5;
    default: return 1;
  }
}

function generateName(type: EquipmentType, wuxing: Wuxing, rarity: Rarity): string {
  const wuxingName = WUXING_NAMES[wuxing];

  const weaponNames = ['剑', '刀', '枪', '戟', '棍'];
  const armorNames = ['甲', '袍', '衣', '铠'];
  const treasureNames = ['珠', '镜', '印', '符', '环'];

  let baseName: string;
  switch (type) {
    case EquipmentType.WEAPON:
      baseName = weaponNames[Math.floor(Math.random() * weaponNames.length)];
      break;
    case EquipmentType.ARMOR:
      baseName = armorNames[Math.floor(Math.random() * armorNames.length)];
      break;
    case EquipmentType.TREASURE:
      baseName = treasureNames[Math.floor(Math.random() * treasureNames.length)];
      break;
  }

  const prefix = rarity === Rarity.EPIC ? '上古' :
                 rarity === Rarity.RARE ? '精良' :
                 rarity === Rarity.UNCOMMON ? '优质' : '';

  return `${prefix}${wuxingName}${baseName}`;
}

function randomInt(min: number, max: number): number {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
```

**Step 2: 导出模块**

修改 `packages/shared/src/index.ts`，添加：

```typescript
export * from './logic/LootGenerator.js';
```

**Step 3: 验证编译**

Run: `cd /Volumes/T7/work/fighting && pnpm build:shared`
Expected: 编译成功

**Step 4: Commit**

```bash
git add packages/shared/src/logic/LootGenerator.ts packages/shared/src/index.ts
git commit -m "feat(shared): add loot generator with auto-pickup logic"
```

---

## Task 10: 更新 BattleScene 使用新引擎

**Files:**
- Modify: `packages/client/src/scenes/BattleScene.ts`

**Step 1: 重构 BattleScene 使用 BattleEngine**

这是一个较大的重构，需要：
1. 导入新的引擎类型
2. 创建 Combatant 转换函数
3. 使用 BattleEngine.run() 获取事件
4. 逐个播放事件动画
5. 战斗结束后显示掉落并自动拾取
6. 跳转到 MapScene 显示三选一节点

由于文件较长，这里提供关键改动点：

```typescript
// 新增导入
import {
  BattleEngine,
  BattleEvent,
  Combatant as EngineCombatant,
  generateEnemies,
  generateLoot,
  getTotalSpeed,
  getAttackWuxing,
  getDefenseWuxing,
} from '@xiyou/shared';

// 修改 runBattle 方法使用引擎
private async runBattle(): Promise<void> {
  // 创建引擎
  const combatants = this.buildCombatants();
  const engine = new BattleEngine(combatants, {
    allowEquipmentChange: this.nodeType !== 'final',
    isPvP: false,
  });

  // 执行战斗
  const result = engine.run();

  // 播放事件动画
  for (const event of result.events) {
    await this.playEvent(event);
  }

  // 处理结果
  if (result.winnerId === 'player') {
    await this.handleVictory();
  } else {
    this.showGameOver();
  }
}

// 新增：处理胜利和掉落
private async handleVictory(): Promise<void> {
  const loot = generateLoot(this.getNodeTypeString(), this.round);

  // 显示掉落
  await this.showLootScreen(loot.items);

  // 自动拾取
  let fragmentsGained = 0;
  for (const item of loot.items) {
    if (!gameState.isInventoryFull()) {
      gameState.addToInventory(item);
    } else {
      fragmentsGained++;
      gameState.addFragment();
    }
  }

  // 显示溢出提示
  if (fragmentsGained > 0) {
    await this.showMessage(`${fragmentsGained} 件物品炼化为碎片`);
  }

  // 跳转到地图（三选一节点）
  this.scene.start('MapScene', {
    mode: this.mode,
    round: this.round + 1,
  });
}
```

**Step 2: 验证编译**

Run: `cd /Volumes/T7/work/fighting && pnpm dev:client`
Expected: 客户端启动成功，可以进入战斗

**Step 3: Commit**

```bash
git add packages/client/src/scenes/BattleScene.ts
git commit -m "refactor(client): use BattleEngine for combat logic"
```

---

## Task 11: 更新 MapScene 移除 RewardScene 跳转

**Files:**
- Modify: `packages/client/src/scenes/MapScene.ts`

**Step 1: 战斗后直接返回 MapScene**

BattleScene 已经处理掉落，MapScene 只需要正常显示三选一节点即可。无需修改 MapScene。

**Step 2: 验证流程**

Run: `cd /Volumes/T7/work/fighting && pnpm dev:client`
Expected: 战斗 → 掉落显示 → MapScene（三选一节点）

**Step 3: Commit (如有改动)**

```bash
git add packages/client/src/scenes/MapScene.ts
git commit -m "refactor(client): update MapScene for new battle flow"
```

---

## Task 12: 为传说装备添加 speed 属性

**Files:**
- Modify: `packages/shared/src/data/EquipmentDatabase.ts`

**Step 1: 更新传说装备添加 speed**

为每件传说装备添加合适的 speed 值：

```typescript
RUYI_JINGU_BANG: {
  // ...existing
  speed: 2,  // 金箍棒速度快
},

JIUCHI_DINGPA: {
  // ...existing
  speed: 0,  // 钉耙较重
},

// ... 其他装备类似
```

**Step 2: 验证编译**

Run: `cd /Volumes/T7/work/fighting && pnpm build:shared`
Expected: 编译成功

**Step 3: Commit**

```bash
git add packages/shared/src/data/EquipmentDatabase.ts
git commit -m "feat(shared): add speed attribute to legendary equipment"
```

---

## Summary

完成以上 12 个任务后，战斗系统将：

1. ✅ 使用速度优先的回合制
2. ✅ 支持五行速度修正
3. ✅ 正确计算五行克制/相生伤害
4. ✅ 战斗引擎可复用于服务端
5. ✅ 多物品掉落 + 自动拾取
6. ✅ 溢出物品转化为碎片
7. ✅ 战斗后直接进入三选一节点

下一步可以继续实现：
- 战斗中换装 UI
- 同步阶段占位
- PvP 配置支持
