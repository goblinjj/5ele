# 西游肉鸽策略游戏 - 技术实现规划

## 1. 技术栈

### 前端
| 技术 | 用途 |
|------|------|
| Phaser 3 | 2D 游戏引擎 |
| TypeScript | 类型安全 |
| Vite | 构建工具 |

### 后端
| 技术 | 用途 |
|------|------|
| Node.js | 运行时 |
| Colyseus | 多人游戏服务器框架 |
| TypeScript | 类型安全 |

### 开发环境
| 技术 | 用途 |
|------|------|
| Docker | 容器化开发与部署 |
| Docker Compose | 多服务编排 |

### 数据存储
- 无数据库，纯内存游戏
- 每局结束数据清空

---

## 2. 项目结构

```
fighting/
├── docker-compose.yml
├── packages/
│   ├── client/                 # 前端游戏
│   │   ├── Dockerfile
│   │   ├── package.json
│   │   ├── vite.config.ts
│   │   ├── index.html
│   │   └── src/
│   │       ├── main.ts         # 入口
│   │       ├── config/         # 游戏配置
│   │       ├── scenes/         # Phaser 场景
│   │       │   ├── BootScene.ts
│   │       │   ├── MenuScene.ts
│   │       │   ├── MapScene.ts      # 节点选择
│   │       │   ├── BattleScene.ts   # 战斗场景
│   │       │   ├── RewardScene.ts   # 三选一
│   │       │   └── ResultScene.ts   # 结算
│   │       ├── entities/       # 游戏实体
│   │       │   ├── Player.ts
│   │       │   ├── Monster.ts
│   │       │   ├── Equipment.ts
│   │       │   └── Treasure.ts      # 法宝
│   │       ├── systems/        # 游戏系统
│   │       │   ├── WuxingSystem.ts  # 五行系统
│   │       │   ├── CombatSystem.ts  # 战斗系统
│   │       │   ├── SynthesisSystem.ts # 合成系统
│   │       │   └── InventorySystem.ts # 背包系统
│   │       ├── network/        # 网络通信
│   │       │   └── GameClient.ts
│   │       ├── ui/             # UI 组件
│   │       └── assets/         # 静态资源
│   │
│   ├── server/                 # 后端服务
│   │   ├── Dockerfile
│   │   ├── package.json
│   │   └── src/
│   │       ├── index.ts        # 入口
│   │       ├── rooms/          # Colyseus 房间
│   │       │   ├── GameRoom.ts
│   │       │   └── schema/     # 状态定义
│   │       │       ├── GameState.ts
│   │       │       ├── PlayerState.ts
│   │       │       └── BattleState.ts
│   │       ├── logic/          # 游戏逻辑
│   │       │   ├── WuxingLogic.ts
│   │       │   ├── CombatLogic.ts
│   │       │   └── SynthesisLogic.ts
│   │       └── data/           # 游戏数据
│   │           ├── equipment.ts
│   │           ├── treasures.ts
│   │           └── monsters.ts
│   │
│   └── shared/                 # 共享代码
│       ├── package.json
│       └── src/
│           ├── types/          # 类型定义
│           │   ├── Wuxing.ts
│           │   ├── Equipment.ts
│           │   └── Player.ts
│           ├── constants/      # 常量
│           └── utils/          # 工具函数
│
└── docs/
    └── plans/
```

---

## 3. 核心系统设计

### 3.1 五行系统 (WuxingSystem)

```typescript
// shared/src/types/Wuxing.ts
export enum Wuxing {
  METAL = 'metal',  // 金
  WOOD = 'wood',    // 木
  WATER = 'water',  // 水
  FIRE = 'fire',    // 火
  EARTH = 'earth',  // 土
}

// 相克关系：金→木→土→水→火→金
export const WUXING_CONQUER: Record<Wuxing, Wuxing> = {
  [Wuxing.METAL]: Wuxing.WOOD,
  [Wuxing.WOOD]: Wuxing.EARTH,
  [Wuxing.EARTH]: Wuxing.WATER,
  [Wuxing.WATER]: Wuxing.FIRE,
  [Wuxing.FIRE]: Wuxing.METAL,
};

// 相生关系：金→水→木→火→土→金
export const WUXING_GENERATE: Record<Wuxing, Wuxing> = {
  [Wuxing.METAL]: Wuxing.WATER,
  [Wuxing.WATER]: Wuxing.WOOD,
  [Wuxing.WOOD]: Wuxing.FIRE,
  [Wuxing.FIRE]: Wuxing.EARTH,
  [Wuxing.EARTH]: Wuxing.METAL,
};
```

```typescript
// 五行战斗计算
interface WuxingLevel {
  wuxing: Wuxing;
  level: number;
}

function calculateDamage(
  attacker: WuxingLevel,
  defender: WuxingLevel,
  baseDamage: number
): number {
  // 相克：伤害加成
  if (WUXING_CONQUER[attacker.wuxing] === defender.wuxing) {
    const bonus = 1 + (attacker.level - defender.level + 1) * 0.2;
    return Math.floor(baseDamage * Math.max(bonus, 1.1));
  }

  // 相生：给对方回血（返回负数表示治疗敌人）
  if (WUXING_GENERATE[attacker.wuxing] === defender.wuxing) {
    const heal = (attacker.level + 1) * 0.5;
    return -Math.floor(baseDamage * heal);
  }

  // 无关系：正常伤害
  return baseDamage;
}
```

### 3.2 装备系统 (Equipment)

```typescript
// shared/src/types/Equipment.ts
export enum EquipmentType {
  WEAPON = 'weapon',
  ARMOR = 'armor',
  TREASURE = 'treasure',  // 法宝
}

export interface Equipment {
  id: string;
  name: string;
  type: EquipmentType;
  wuxing: Wuxing;
  wuxingLevel: number;

  // 基础属性
  attack?: number;
  defense?: number;

  // 附带技能
  skillId?: string;

  // 升级等级
  upgradeLevel: number;
}

export interface PlayerEquipment {
  weapon: Equipment | null;
  armor: Equipment | null;
  treasures: Equipment[];  // 5-8 个法宝
}
```

### 3.3 合成系统 (SynthesisSystem)

```typescript
// server/src/logic/SynthesisLogic.ts

interface SynthesisResult {
  success: boolean;
  result?: Equipment;      // 成功时的产物
  fragment?: boolean;      // 是否产生碎片
  destroyedIndex: 0 | 1;   // 哪个装备被销毁/分解
}

// 合成概率表（黑盒，不暴露给客户端）
const SYNTHESIS_RATES = {
  same: 0.5,      // 同属性 50%
  generate: {     // 相生：因属性而异
    [Wuxing.METAL]: 0.3,
    [Wuxing.WATER]: 0.2,
    [Wuxing.WOOD]: 0.3,
    [Wuxing.FIRE]: 0.2,
    [Wuxing.EARTH]: 0.3,
  },
  conquer: {      // 相克：因属性而异
    [Wuxing.METAL]: 0.2,
    [Wuxing.WATER]: 0.3,
    [Wuxing.WOOD]: 0.2,
    [Wuxing.FIRE]: 0.3,
    [Wuxing.EARTH]: 0.2,
  },
};

// 碎片加成（每个 +5%）
const FRAGMENT_BONUS = 0.05;

function synthesize(
  equip1: Equipment,
  equip2: Equipment,
  fragmentCount: number
): SynthesisResult {
  // 计算基础概率
  let rate = getBaseRate(equip1.wuxing, equip2.wuxing);

  // 加上碎片加成
  rate += fragmentCount * FRAGMENT_BONUS;
  rate = Math.min(rate, 0.95);  // 上限 95%

  // 检查特定配方
  const specialResult = checkSpecialRecipe(equip1, equip2);
  if (specialResult) {
    return { success: true, result: specialResult, destroyedIndex: 0 };
  }

  // 通用合成
  if (Math.random() < rate) {
    // 成功：随机选择一个装备升级
    const upgradeIndex = Math.random() < 0.5 ? 0 : 1;
    const upgraded = upgradeIndex === 0 ? equip1 : equip2;
    return {
      success: true,
      result: upgradeEquipment(upgraded),
      destroyedIndex: upgradeIndex === 0 ? 1 : 0,
    };
  } else {
    // 失败：随机一个变成碎片
    return {
      success: false,
      fragment: true,
      destroyedIndex: Math.random() < 0.5 ? 0 : 1,
    };
  }
}
```

### 3.4 背包系统 (InventorySystem)

```typescript
// shared/src/types/Inventory.ts
export const INVENTORY_SIZE = 10;  // 背包容量

export interface Inventory {
  slots: (Equipment | null)[];
  fragmentCount: number;  // 法宝碎片数量
}

// client/src/systems/InventorySystem.ts
export class InventorySystem {
  private inventory: Inventory;

  constructor() {
    this.inventory = {
      slots: new Array(INVENTORY_SIZE).fill(null),
      fragmentCount: 0,
    };
  }

  isFull(): boolean {
    return this.inventory.slots.every(slot => slot !== null);
  }

  add(equipment: Equipment): boolean {
    const emptyIndex = this.inventory.slots.findIndex(s => s === null);
    if (emptyIndex === -1) return false;
    this.inventory.slots[emptyIndex] = equipment;
    return true;
  }

  remove(index: number): Equipment | null {
    const item = this.inventory.slots[index];
    this.inventory.slots[index] = null;
    return item;
  }

  addFragment(): void {
    this.inventory.fragmentCount++;
  }
}
```

### 3.5 战斗系统 (CombatSystem)

```typescript
// server/src/logic/CombatLogic.ts

interface Combatant {
  id: string;
  hp: number;
  maxHp: number;
  attack: number;
  defense: number;
  attackWuxing: WuxingLevel;
  defenseWuxing: WuxingLevel;
  position: { x: number; y: number };
  skills: Skill[];
}

interface BattleResult {
  winner: string | null;  // null = Boss 获胜
  rounds: BattleRound[];
  reveals: TrapReveal[];  // 延迟揭示的陷害
}

// 获取战斗站位
function getPositions(playerCount: number): Position[] {
  switch (playerCount) {
    case 2:
      return [
        { x: 0, y: 0 },   // 左
        { x: 2, y: 0 },   // 右
      ];
    case 3:
      return [
        { x: 1, y: 0 },   // 上
        { x: 0, y: 1 },   // 左下
        { x: 2, y: 1 },   // 右下
      ];
    case 4:
      return [
        { x: 0, y: 0 },   // 左上
        { x: 2, y: 0 },   // 右上
        { x: 0, y: 2 },   // 左下
        { x: 2, y: 2 },   // 右下
      ];
  }
}

// 自动战斗逻辑
function runBattle(
  players: Combatant[],
  boss: Combatant | null
): BattleResult {
  const rounds: BattleRound[] = [];
  const combatants = boss ? [...players, boss] : [...players];

  while (getAlivePlayers(combatants).length > 1 ||
         (boss && boss.hp > 0 && getAlivePlayers(players).length > 0)) {
    const round = processRound(combatants, boss);
    rounds.push(round);

    if (rounds.length > 100) break;  // 防止无限循环
  }

  const alivePlayers = getAlivePlayers(players);
  return {
    winner: alivePlayers.length === 1 ? alivePlayers[0].id : null,
    rounds,
    reveals: [],  // 战斗结束后填充
  };
}
```

---

## 4. 网络通信设计

### 4.1 Colyseus 房间状态

```typescript
// server/src/rooms/schema/GameState.ts
import { Schema, MapSchema, ArraySchema, type } from "@colyseus/schema";

export class PlayerState extends Schema {
  @type("string") id: string;
  @type("string") name: string;
  @type("number") hp: number;
  @type("number") maxHp: number;
  @type("string") weaponWuxing: string;  // 外显信息
  @type("string") armorWuxing: string;   // 外显信息
  @type("number") weaponLevel: number;
  @type("number") armorLevel: number;
  @type("boolean") isInjured: boolean;   // 状态外显
  @type("boolean") isReady: boolean;
}

export class GameState extends Schema {
  @type("string") phase: string;  // 'waiting' | 'exploring' | 'battle' | 'reward' | 'final'
  @type("number") round: number;
  @type({ map: PlayerState }) players = new MapSchema<PlayerState>();
  @type("string") currentNodeOptions: string;  // JSON 序列化的节点选项
}
```

### 4.2 消息类型

```typescript
// shared/src/types/Messages.ts

// 客户端 → 服务端
export type ClientMessage =
  | { type: 'ready' }
  | { type: 'selectNode'; nodeIndex: number }
  | { type: 'selectReward'; rewardIndex: number }
  | { type: 'synthesize'; slot1: number; slot2: number }
  | { type: 'devour'; targetSlot: number; sacrificeSlot: number }
  | { type: 'equipWeapon'; slot: number }
  | { type: 'equipArmor'; slot: number }
  | { type: 'useTrapCard'; targetPlayerId: string; cardId: string }
  | { type: 'confirmBattle' };

// 服务端 → 客户端
export type ServerMessage =
  | { type: 'gameStart'; players: PlayerInfo[] }
  | { type: 'nodeOptions'; options: NodeOption[] }
  | { type: 'battleStart'; combatants: CombatantInfo[] }
  | { type: 'battleRound'; actions: BattleAction[] }
  | { type: 'battleEnd'; result: BattleResult }
  | { type: 'rewards'; options: Equipment[] }
  | { type: 'phaseChange'; phase: string }
  | { type: 'trapUsed'; targetId: string }  // 不透露使用者
  | { type: 'gameEnd'; winner: string; reveals: TrapReveal[] };
```

---

## 5. Docker 配置

### docker-compose.yml

```yaml
version: '3.8'

services:
  client:
    build:
      context: ./packages/client
      dockerfile: Dockerfile
    ports:
      - "5173:5173"
    volumes:
      - ./packages/client/src:/app/src
      - ./packages/shared:/shared
    environment:
      - VITE_SERVER_URL=ws://localhost:2567
    depends_on:
      - server

  server:
    build:
      context: ./packages/server
      dockerfile: Dockerfile
    ports:
      - "2567:2567"
    volumes:
      - ./packages/server/src:/app/src
      - ./packages/shared:/shared
    environment:
      - NODE_ENV=development
```

### packages/client/Dockerfile

```dockerfile
FROM node:20-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .

# 链接共享包
RUN npm link /shared

EXPOSE 5173

CMD ["npm", "run", "dev", "--", "--host"]
```

### packages/server/Dockerfile

```dockerfile
FROM node:20-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .

# 链接共享包
RUN npm link /shared

EXPOSE 2567

CMD ["npm", "run", "dev"]
```

---

## 6. 开发阶段详细任务

### 阶段 1：核心原型（单人可玩）

```
Week 1-2:
├── 项目初始化
│   ├── 创建 monorepo 结构
│   ├── 配置 TypeScript
│   ├── 配置 Docker Compose
│   └── Phaser 3 基础场景
│
├── 核心场景
│   ├── BootScene（加载资源）
│   ├── MenuScene（开始菜单）
│   ├── MapScene（节点地图）
│   └── BattleScene（战斗场景）
│
├── 五行系统
│   ├── 五行类型定义
│   ├── 相生相克计算
│   └── 伤害/治疗公式
│
├── 装备系统
│   ├── 装备数据结构
│   ├── 武器/铠甲/法宝
│   └── 技能附带
│
└── 单人战斗
    ├── 自动战斗逻辑
    ├── 回合制流程
    └── Boss 战斗
```

### 阶段 2：合成与背包

```
Week 3:
├── 背包系统
│   ├── 8-10 格背包 UI
│   ├── 装备拖拽
│   └── 穿戴/卸下
│
├── 合成系统
│   ├── 通用规则实现
│   ├── 特定配方表
│   ├── 碎片机制
│   └── 合成 UI
│
└── 吞噬系统
    ├── 吞噬逻辑
    └── 概率计算
```

### 阶段 3：联机功能

```
Week 4-5:
├── Colyseus 服务端
│   ├── 房间创建
│   ├── 状态同步
│   └── 游戏逻辑移至服务端
│
├── 客户端网络
│   ├── 连接管理
│   ├── 状态订阅
│   └── 消息发送
│
├── 同步机制
│   ├── 等待界面
│   ├── 外显信息展示
│   └── 准备确认
│
└── PvPvE 混战
    ├── 多人战斗逻辑
    ├── Boss 随机攻击
    └── 胜负判定
```

### 阶段 4：互动与打磨

```
Week 6:
├── 陷害系统
│   ├── 陷害卡获取
│   ├── 同步阶段使用
│   └── 延迟揭示
│
├── 81 难剧情
│   ├── 女儿国
│   ├── 火焰山
│   └── 通天河
│
├── 美术资源
│   ├── 角色立绘
│   ├── 装备图标
│   ├── 粒子特效
│   └── UI 美化
│
└── 测试与优化
    ├── 平衡性测试
    ├── 性能优化
    └── Bug 修复
```

---

## 7. 关键技术点

### 7.1 等距视角渲染

```typescript
// client/src/utils/IsometricUtils.ts
export function cartesianToIsometric(x: number, y: number): { x: number; y: number } {
  return {
    x: (x - y) * TILE_WIDTH_HALF,
    y: (x + y) * TILE_HEIGHT_HALF,
  };
}

export function isometricToCartesian(x: number, y: number): { x: number; y: number } {
  return {
    x: (x / TILE_WIDTH_HALF + y / TILE_HEIGHT_HALF) / 2,
    y: (y / TILE_HEIGHT_HALF - x / TILE_WIDTH_HALF) / 2,
  };
}
```

### 7.2 战斗动画队列

```typescript
// client/src/systems/BattleAnimationQueue.ts
export class BattleAnimationQueue {
  private queue: BattleAction[] = [];
  private isPlaying = false;

  add(action: BattleAction): void {
    this.queue.push(action);
    if (!this.isPlaying) this.playNext();
  }

  private async playNext(): Promise<void> {
    if (this.queue.length === 0) {
      this.isPlaying = false;
      return;
    }

    this.isPlaying = true;
    const action = this.queue.shift()!;
    await this.playAction(action);
    this.playNext();
  }

  private playAction(action: BattleAction): Promise<void> {
    // 根据 action 类型播放对应动画
  }
}
```

---

## 附录：临时占位资源

开发初期使用简单几何图形作为占位：

```typescript
// 临时角色：彩色圆形
this.add.circle(x, y, 30, wuxingColors[wuxing]);

// 临时武器：三角形
this.add.triangle(x, y, 0, 20, 10, 0, 20, 20, wuxingColors[wuxing]);

// 临时铠甲：矩形
this.add.rectangle(x, y, 40, 50, wuxingColors[wuxing]);

// 五行颜色
const wuxingColors = {
  metal: 0xFFFFFF,  // 白
  wood: 0x00FF00,   // 绿
  water: 0x0000FF,  // 蓝
  fire: 0xFF0000,   // 红
  earth: 0xFFFF00,  // 黄
};
```

---

*文档版本：v1.0*
*创建日期：2026-01-31*
